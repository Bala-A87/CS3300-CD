//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

//import jdk.nashorn.internal.codegen.SpillObjectCreator;



/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJDepthFirst<R,A> implements GJVisitor<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //

    int noSpilled;
    boolean build;
    BasicBlock currStmt;
    String currScope;
    HashMap<String, HashMap<Integer, TEMP>> tempMap;
    ControlFlowGraph controlFlowGraph;

    public GJDepthFirst() {
      noSpilled = 0;
      build = true;
      currStmt = null;
      currScope = null;
      tempMap = null;
      controlFlowGraph = new ControlFlowGraph();
    }
	
	
   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return (R)n.tokenImage; }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n, A argu) {
      R _ret=null;
      if(build) {
         String procedureName = (String)(n.f0.accept(this, argu));      
         n.f1.accept(this, argu);
         Integer noOfArguments = (Integer)(n.f2.accept(this, argu));    
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
      }
      else {
         n.f0.accept(this, argu);      
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);    
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
      }
      return _ret;
   }

//
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      R _ret=null;

      n.f0.accept(this, argu);
      currScope = "MAIN";
      tempMap =  new HashMap<String, HashMap<Integer, TEMP>>();
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);      
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);      

      build = false;

      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);      
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);  

      return _ret;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) {
      R _ret=null;  
      if(build) {
         currStmt = new BasicBlock();
         n.f0.accept(this, argu);   
         controlFlowGraph.addNode(currStmt);
      }
      else {
         n.f0.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) {
      R _ret=null;
      if(build) {
         n.f0.accept(this, argu);
      }
      else {
         n.f0.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
      R _ret=null;
      if(build) {
         n.f0.accept(this, argu);
      }
      else {
         n.f0.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) {
      R _ret=null;
      if(build) {
         n.f0.accept(this, argu);
         Integer tempNo = (Integer)(n.f1.accept(this, argu));
         TEMP usedTemp = tempMap.get(currScope).get(tempNo);
         currStmt.addUse(usedTemp);
         n.f2.accept(this, argu);
      }
      else {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) {
      R _ret=null;
      if(build) {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
      }
      else {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) {
      R _ret=null;
      if(build) {
         n.f0.accept(this, argu);
         Integer tempNo = (Integer)(n.f1.accept(this, argu));
         TEMP locationTemp = tempMap.get(currScope).get(tempNo);
         n.f2.accept(this, argu);
         tempNo = (Integer)(n.f3.accept(this, argu));
         TEMP storageTemp = tempMap.get(currScope).get(tempNo);
         currStmt.addUse(locationTemp);
         currStmt.addDef(storageTemp);
      }
      else {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) {
      R _ret=null;
      if(build) {
         n.f0.accept(this, argu);
         Integer tempNo = (Integer)(n.f1.accept(this, argu));
         TEMP storageTemp = tempMap.get(currScope).get(tempNo);
         tempNo = (Integer)(n.f2.accept(this, argu));
         TEMP locationTemp = tempMap.get(currScope).get(tempNo);
         currStmt.addUse(locationTemp);
         currStmt.addDef(storageTemp);
         n.f3.accept(this, argu);
      }
      else {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) {
      R _ret=null;
      if(build) {
         n.f0.accept(this, argu);
         Integer tempNo = (Integer)(n.f1.accept(this, argu));
         TEMP destinationTemp = tempMap.get(currScope).get(tempNo);
         currStmt.addDef(destinationTemp);
         n.f2.accept(this, argu);
      }
      else {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) {
      R _ret=null;
      if(build) {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);  
      }    
      else {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);  
      }
      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n, A argu) {
      R _ret=null;
      if(build) {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
      }
      else {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) {
      R _ret=null;
      if(build) {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
      }
      else {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) {
      R _ret=null;
      if(build) {
         n.f0.accept(this, argu);
         Integer tempNo = (Integer)(n.f1.accept(this, argu));
         TEMP usedTemp = tempMap.get(currScope).get(tempNo);
         currStmt.addUse(usedTemp);
         n.f2.accept(this, argu);
      }
      else {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public R visit(Operator n, A argu) {
      R _ret=n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      R tempNo = n.f1.accept(this, argu);
      return tempNo;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) {
      R _ret=n.f0.accept(this, argu);
      return _ret;
   }

   class TEMP {
      int no;
      String scope;
      boolean spilled;
      String allocatedRegister;
      int spilledArgNo;

      public TEMP(int tempNo, String currScope) {
         no = tempNo;
         scope = new String(currScope);
         spilled = false;
         allocatedRegister = "";
         spilledArgNo = -1;
      }

      public TEMP(TEMP copy) {
         no = copy.no;
         scope = new String(copy.scope);
         spilled = copy.spilled;
         allocatedRegister = new String(copy.allocatedRegister);
         spilledArgNo = copy.spilledArgNo;
      }

      public void allocateRegister(String register) {
         spilled = false;
         allocatedRegister = new String(register);
      }

      public void spillArg() {
         spilled = true;
         spilledArgNo = noSpilled++;
      }

      public boolean equals(TEMP arg) {
         return (no == arg.no && scope.equals(arg.scope));
      }
   }

   class BasicBlock {
      // BasicBlock prev;
      Set<TEMP> used, def, liveIn, liveOut;
      ArrayList<BasicBlock> succ;


      public BasicBlock() {
         // this.prev = prev;
         used = new HashSet<TEMP>();
         def = new HashSet<TEMP>();
         liveIn = new HashSet<TEMP>();
         liveOut = new HashSet<TEMP>();
         succ = new ArrayList<BasicBlock>();
      }

      public BasicBlock(BasicBlock copy) {
         used = new HashSet<TEMP>(copy.used);
         def = new HashSet<TEMP>(copy.def);
         liveIn = new HashSet<TEMP>(copy.liveIn);
         liveOut = new HashSet<TEMP>(copy.liveOut);
         succ = new ArrayList<BasicBlock>(copy.succ);
      }

      public void addUse(TEMP usedTemp) {
         used.add(usedTemp);
      }

      public void addDef(TEMP defTemp) {
         def.add(defTemp);
      }

      public void addSuccessor(BasicBlock succ) {
         this.succ.add(succ);
      }

      public void getLiveness() {
         getLiveOut();
         getLiveIn();
      }

      public void getLiveIn() {
         liveIn.addAll(used);
         Set<TEMP> out_def = new HashSet<TEMP>(liveOut);
         for(TEMP defn : def)
            out_def.remove(defn);
         liveIn.addAll(out_def);
      }

      public void getLiveOut() {
         for(BasicBlock succBlock : succ) liveOut.addAll(succBlock.liveIn);
      }
   }

   class ControlFlowGraph {
      BasicBlock start;
      BasicBlock last;

      public ControlFlowGraph() {
         start = null;
         last = null;
      }

      public void addNode(BasicBlock newNode) {
         // May have to be modified to allow addition to jumps
         if(last == null) {
            start = new BasicBlock(newNode);
            last = start;
         }
         else {
            BasicBlock addedNode = new BasicBlock(newNode);
            last.addSuccessor(addedNode);
            last = addedNode;
         }
      }
   }

}
